# headache solve

ignore all the junk in this folder the solve is in solve.py

uhhhhhhhhhhhh ok i barely remember this challenge but i will try to recall it and explain my solve here

ok the challenge is about a pipeline of input -> char filtering -> put in headache compiler -> run in brainfuck interpreter

looking at the brainfuck interpreter source (much easier to look at since brainfuck is fairly simple) we can see the issue:

https://github.com/tunsinge/BrainfuckInterpreter/blob/main/main.c#L29-L32

there are no bounds checking on the `<>+-` operations so if we can get the compiler to generate those then we are good

also of note is that `,.` dont have bounds checking, but `[]` do (they have issues if > 29999).

since the `ptr` var is a ptr to somewhere on the stack, we can just try to get it to go to the return address and hijack that, while
also easily dodging the stack canary

the headache compiler can be tested at https://headache.surge.sh/test.html

one thing you might notice is that simple stuff requires a whole bunch of brainfuck to run 

```
Generated by HAC (Headache Awesome Compiler) 
CL
>>>>>>>[-]++++++++++KInt
>[-]>[-] <<[>+>+<<-] >>[<<+>>-]<<<[-]>[<+>-][-]>[<+>-]Assign
>>>>>>>>>>[-] <<<<<<<<<<<<[>>>>>>+>>>>>>+<<<<<<<<<<<<-] >>>>>>>>>>>>[<<<<<<<<<<<<+>>>>>>>>>>>>-]<<<<<<[<+<+>>-]<>>++++++++++<<[->+>-[>+>>]>[+[-<+>]>+>>]<<<<<<]>>[-]>>>++++++++++<[->-[>+>>]>[+[-<+>]>+>>]<<<<<]>[-]>>[>++++++[-<++++++++>]<.<<+>+>[-]]<[<[->-<]++++++[->++++++++<]>.[-]]<<++++++[-<++++++++>]<.[-]<<[-<+>]<<[>>+<<-]>>[-]<[-]<[-]print byte
```

for

```
void main () { 
    byte b;
    b = 10;
    print b;
} 
```

however, this is only because it has to convert the number into an ascii string and then print it

we can use the `char` type to get around this instead of `byte` since it just prints it as a char straight up

```
Generated by HAC (Headache Awesome Compiler) 
CL
>>>>>>>[-]++++++++++KInt
Cast
>[-]>[-] <<[>+>+<<-] >>[<<+>>-]<<<[-]>[<+>-][-]>[<+>-]Assign
<<.print char
```

the way the compiler works is that for writing intermediates to vars it allocates a spot on the stack for them and then copies them over

instead of just `++++ etc ++++` or whatever

also lol `--maga` flag why does that even exist

we can see that in the codeGoTo function in the compiler it does check that we aren't going above 30000 ... but only if we are making a relative shift of 30000 or more

https://github.com/LucasMW/Headache/blob/3cdadaeb340673c198bf82df8be5c244c972cde0/src/codeGen.c#L188-L205

this means we can make 2 shifts and it will be ok

also we can use the `print` and `read` keywords instead of those other chars and `/**/` for spacing since it uses
a bison grammar or something which probably handles that ok

also recursion isnt really possible

ummm idk i was having issues i think with some weird heap thing ? i couldnt exploit that or figure out that

![heap bogus](https://i.ibb.co/Y72DSQgR/image.png)

umm also you cant define too many variables (more than 1000 technically) otherwise it corrupts stuff in globals i think

https://github.com/LucasMW/Headache/blob/3cdadaeb340673c198bf82df8be5c244c972cde0/src/symbolTable.c#L41

umm also you cant use `short` or `int` types since those require padding or something even for the byte types for compatibility or something ??? idk

https://github.com/LucasMW/Headache/blob/3cdadaeb340673c198bf82df8be5c244c972cde0/src/codeGen.c#L875-L882

https://github.com/LucasMW/Headache/blob/3cdadaeb340673c198bf82df8be5c244c972cde0/src/expander.c#L68-L90

so what i vaguely remember doing was using one function to slowly "allocate" stuff on the headache vars stack and offset the next place to allocate from

so like `g()` might take up bf slots 0-999, `g()` for a second time would take 1000-1999, etc

this weird function stuff helped me control the allocation order a lot which was nice

i think i used a one gadget once i figured out the overwrite offsets in gdb (at `0xcd69a`)

so like the last 12 bits had to be 69a and since `__libc_start_main` or whatever was at a specific offset,
i could increment the last byte (low 8 bits) and overflow it guaranteed. for the `d6` byte, i knew how much i had to increment that byte by, but
it could potentially overflow that byte when adding and go into the next byte, so i had to account for that with some artificial overflow
so doing `+0xd` instead of `+0xc` for the high byte (its 3am rn and i dont know what im saying)

ok

~~solve.py has some workings but the real solve comes from `cat out.txt - | nc localhost 5000` or whatever the ip and port are. press enter after running the command~~

solve.py should just work now i think

dont forget this interpreter is slow asf so it might take a hot minute (like 30 seconds) for it to come through. flag in `/` so just `cat /flag*`

## update

lmao i made this challenge before donald over here claimed that autism is caused by tylenol or something

unintentional donald ~~duck~~ trump coincidence is crazy

